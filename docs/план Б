# План улучшения Astra: Поэтапный рабочий план для CODEX (v2)

Этот план переписан под текущую архитектуру репозитория и исполнение в CODEX.

## Факты по текущему репо (без предположений)

- UI: `Tauri + React` (`apps/desktop`).
- API: `FastAPI` (`apps/api`).
- Оркестрация: `core/planner.py`, `core/run_engine.py`, `core/intent_router.py`.
- Память/хранилище: `SQLite` уже есть (`memory/db.py`, `memory/store.py`).
- Поиск: skill `web_research` уже есть (`skills/web_research/skill.py`), есть auto web research в `CHAT` (`apps/api/routes/runs.py`).
- Автопилот: через desktop bridge (`apps/desktop/src-tauri/src/bridge.rs`) + `core/executor/computer_executor.py`.
- Напоминания/Telegram: уже есть (`core/reminders/scheduler.py`, `apps/api/routes/reminders.py`).

## Как выполнять промпты

1. Вставляешь один промпт в CODEX.
2. После выполнения скидываешь diff + результаты тестов.
3. Если тесты красные, фиксируем фазу до зелёного и только потом идём дальше.
4. Для OpenClaw-интеграции работаем волнами: по 10 навыков за итерацию (batch-10), не массово.
5. После каждой волны обязательно: smoke + автотесты + метрики + короткий отчёт "что изменилось/что сломалось/что откатили".
6. Только после зелёной волны переходим к следующей десятке. Цикл повторяется до полного покрытия целевого каталога (вплоть до 300+ итераций при необходимости).

## Глобальные метрики качества (DoD)

- `Brain quality`: минимум 85% прохождения набора регрессионных кейсов.
- `Clean output`: в финальном ответе нет мусора/битого текста/случайных иероглифов.
- `Latency`: p95 ответа в `CHAT` для коротких запросов <= 12s на твоём железе.
- `Reliability`: ни одна фаза не считается завершённой без автотестов.

## Фаза 0. База и измеримость (5 промптов)

1. **Промпт**: "Сделай аудит текущих точек, влияющих на качество ответа, только в существующей архитектуре (без внедрения LangChain). Проверь `apps/api/routes/runs.py`, `core/intent_router.py`, `core/planner.py`, `core/brain/router.py`, `prompts/*`. Выдай список топ-10 причин деградации качества и план фиксов по файлам."
2. **Промпт**: "Добавь regression-набор `tests/test_brain_regressions.py` с кейсами из жалоб: сложный запрос (похудение), грязный поиск, неверная декомпозиция, потеря контекста. Каждый тест должен иметь чёткий pass/fail критерий."
3. **Промпт**: "Не трогая `requirements.txt` и без авто-установки в runtime, добавь недостающие dev-зависимости только в `requirements-dev.txt` (если реально нужны) и обнови `docs/DEVELOPMENT.md` как запускать тесты."
4. **Промпт**: "Добавь тех.метрики в рантайм: лог времени ответа, выбор intent, срабатывание auto-web-research, fallback-path. Сохрани в существующие run events/store, не ломая API-контракты."
5. **Промпт**: "Обнови документацию: `docs/ARCHITECTURE.md` (поток ответа), `docs/CONFIG.md` (только реально используемые ENV для качества), `docs/TROUBLESHOOTING.md` (симптомы 'мусорный ответ', 'долгий ответ')."

DoD фазы 0:
- Есть измеримый baseline по качеству и скорости.
- Есть regression-тесты на реальные проблемные кейсы.

## Фаза 1. Исправление “мозгов” (12 промптов)

6. **Промпт**: "Усиль `IntentRouter.decide` и fast-path правила в `apps/api/routes/runs.py`: чтобы сложные запросы не падали в примитивный chat-path. Добавь тесты на границе 'простой vs сложный'."
7. **Промпт**: "Добавь deterministic pre-check перед финальным ответом: если ответ пустой/битый/нерелевантный, запускай ровно одну safe-попытку пересборки ответа с тем же контекстом."
8. **Промпт**: "Реализуй internal-reasoning policy: модель может думать внутри, но пользователю отдаётся только чистый результат (без явного CoT). Добавь тест, что internal notes не протекают в UI."
9. **Промпт**: "Добавь авто-выбор режима ответа: `direct answer` для простых запросов, `step-by-step plan` для сложных. Точка переключения должна быть явной и покрыта тестами."
10. **Промпт**: "Улучши учёт контекста диалога в `runs.py`: использовать последние релевантные сообщения и память пользователя, но с лимитами, чтобы не раздувать промпт и не тормозить."
11. **Промпт**: "Добавь пост-обработчик финального текста: краткий итог сверху, детали ниже, без мусорных символов, без дублирования. Не менять JSON-контракты API."
12. **Промпт**: "Сделай анти-шаблонный слой: если ответ слишком похож на шаблонные заготовки, перегенерируй в пределах текущего бюджет/таймаута."
13. **Промпт**: "Усиль fallback при сбоях LLM: полезный ответ вместо 'тишины' и без кракозябр; добавь reason-code в события."
14. **Промпт**: "Тонкая настройка модели по сложности запроса через существующие ENV (`ASTRA_LLM_*`), без смены основного стека."
15. **Промпт**: "Добавь нагрузочный тест `tests/test_latency_chat_path.py` для коротких/средних/сложных запросов и отчёт p50/p95."
16. **Промпт**: "Добавь golden-кейсы для сложных запросов: корректная декомпозиция, корректные шаги, нет токсичного мусора."
17. **Промпт**: "Собери фаза-отчёт: что поменялось в точности intent, качестве ответа и времени ответа. Добавь в `docs/DEVELOPMENT.md` раздел 'Quality gate'."

DoD фазы 1:
- Регрессионные кейсы по 'мозгам' проходят >= 85%.
- Ответы чистые и структурные, без явного CoT в выдаче.

## Фаза 2. Характер и стиль общения (6 промптов)

18. **Промпт**: "Синхронизируй `prompts/core_identity.md`, `prompts/tone_pipeline.md`, `prompts/variation_rules.md`: единые правила стиля, чтобы не было конфликтов."
19. **Промпт**: "Добавь хранилище пользовательских предпочтений тона (строгий/дружелюбный/краткий) через существующую память, без отдельного нового фреймворка."
20. **Промпт**: "Реализуй адаптацию тона по контексту: стиль меняется, но смысл и точность не проседают."
21. **Промпт**: "Добавь лимит многословности: если пользователь не просит подробно, ответ остаётся компактным."
22. **Промпт**: "Тесты характера: 8 сценариев (строго/дружелюбно/юмор/нейтрально/мат в запросе/короткий формат/длинный формат/переключение стиля в диалоге)."
23. **Промпт**: "Добавь в UI-модель метаданные 'выбранный стиль ответа' для диагностики, без показа служебки пользователю."

DoD фазы 2:
- Характер предсказуемо подстраивается.
- Время ответа не деградирует из-за tone-пайплайна.

## Фаза 3. Поиск в интернете (8 промптов)

24. **Промпт**: "Доработай существующий `skills/web_research/skill.py`: фильтрация мусорных/off-topic источников, дедуп URL, жёсткая чистка текста перед финальным ответом."
25. **Промпт**: "Улучши `_compose_web_research_chat_text` в `apps/api/routes/runs.py`: формат 'Итог -> Детали -> (опционально) источники', чтобы ответ был читабельным."
26. **Промпт**: "Добавь защиту от мусорной выдачи (битые символы, случайные иероглифы, урезанные фразы). Если найдено — rebuild ответа из валидных фрагментов."
27. **Промпт**: "Подстрой auto-web-research эвристику (`_should_auto_web_research`): запускать только когда это реально нужно, чтобы не тормозить обычный чат."
28. **Промпт**: "Сделай конфигурируемые лимиты для web_research через существующие ENV/inputs и зафиксируй их в `docs/CONFIG.md`."
29. **Промпт**: "Добавь тесты на кейсы: свежая инфа, спорная инфа, off-topic, мало источников, плохой источник."
30. **Промпт**: "Добавь smoke-тест, где запрос похож на твой проблемный пример (аниме/сюжет), и проверяй, что финальный текст чистый."
31. **Промпт**: "Собери отчёт по фазе: доля успешных web-ответов, среднее число использованных источников, среднее время."

DoD фазы 3:
- Поиск даёт чистые ответы без мусора.
- Auto-web-research не ломает обычный чат.

Порядок выполнения после фазы 3:
- Сейчас пропускаем автопилот и идём в текущие фазы 5 -> 6 -> 7 -> 8.
- Блок автопилота выполняем только в самом конце, после завершения остального плана.

## Фаза 4 (отложенная, выполняется последней). Управление компьютером (автопилот) (6 промптов)

32. **Промпт**: "Добавь preflight-проверку прав через `/autopilot/permissions` до запуска действий; если прав нет — понятный ответ с инструкцией."
33. **Промпт**: "Усиль стабильность `core/executor/computer_executor.py`: retries, loop-break, no-progress handling; параметры только через существующие `ASTRA_EXECUTOR_*`."
34. **Промпт**: "Сделай обязательный preview + approval для рискованных действий, убедись что события корректно пишутся в store."
35. **Промпт**: "Добавь улучшенную диагностику автопилота: reason-code на каждый отказ/сбой (`permission_denied`, `no_progress`, `action_failed`)."
36. **Промпт**: "Расширь `tests/test_autopilot_events.py`: кейсы на retry, no-progress, permission-fail, успешный микрошаг."
37. **Промпт**: "Обнови `docs/TROUBLESHOOTING.md` раздел автопилота: быстрые команды диагностики и частые причины 'дёргает мышкой и падает'."

DoD фазы 4:
- Автопилот либо делает действие, либо даёт внятную диагностику.
- Нет немых падений.
- Эту фазу запускать только после завершения остальных активных фаз плана.

## Фаза 5. Память и напоминания (оставлено без изменений по твоей просьбе)

49. **Промпт для памяти**: "Используй SQLite для долгосрочной памяти: храни факты, планы."
50. **Промпт для напоминаний**: "Интегрируй python-telegram-bot: job queue для scheduled reminders."
51. **Промпт для проактивности**: "Анализируй контекст: если критично — напомни без запроса."
52. **Промпт**: "Храни user life context, добавь тесты на забывание."
53. **Промпт**: "Проверь работу напоминаний через несколько дней/недель с тестовыми записями."

## Фаза 6. Автономность и участие в жизни (4 промпта)

54. **Промпт**: "Собери минимальный контур проактивности: события дня -> краткий check-in в Telegram (без спама)."
55. **Промпт**: "Добавь правила частоты и quiet-hours для proactive-сообщений."
56. **Промпт**: "Привяжи напоминания и персональный контекст к одному формату памяти."
57. **Промпт**: "Тесты на дубли и спам: не отправлять одно и то же несколько раз."

DoD фазы 6:
- Проактивность полезная и контролируемая.

## Фаза 7. Скорость, запуск и интерфейс (4 промпта)

64. **Промпт для скорости**: "Оптимизируй chat-path: стриминг, async, ограничение лишних вызовов, улучшение p95."
65. **Промпт для интерфейса**: "Улучши чат-окно в текущем стеке `Tauri + React`: читаемость, плотность информации, чистый рендер markdown, удобные состояния loading/error."
66. **Промпт**: "Добавь профилирование времени по этапам ответа: intent, LLM, postprocess, web_research."
67. **Промпт**: "Добавь regression-тесты на время ответа и читаемость финального текста."

## Фаза 8. Интеграция OpenClaw-скиллов (импорт, тесты, метрики) (12 промптов)

68. **Промпт**: "Сделай формальный контракт внешнего навыка для Astra: `id`, `name`, `source_repo`, `source_commit`, `entrypoint`, `inputs_schema`, `outputs_schema`, `permissions`, `risk_level`, `timeout_ms`, `status` (`direct|adapter|blocked`). Добавь схему в `schemas/` и валидацию в `core/skills/schemas.py`."
69. **Промпт**: "Сделай импортёр каталога из `docs/OPENCLAW_SKILLS_ASTRA_ASSESSMENT.md` -> `skills/registry/openclaw_catalog.json` с полями: категория, описание, нужность, url, slug, hash. Добавь `dry-run` режим и отчёт, не меняющий боевой registry."
70. **Промпт**: "Добавь дедупликацию при импорте (по slug/url/name), обработку битых строк и конфликтов. Сохраняй отчёт в `artifacts/skill_import/`."
71. **Промпт**: "Сделай классификатор совместимости `direct|adapter|blocked` по правилам безопасности и архитектуры Astra. В `blocked` отправляй навыки с опасными правами без approval-пути."
72. **Промпт**: "Реализуй adapter-layer для внешних навыков: унификация входов/выходов под текущий раннер (`core/skills/runner.py`) без поломки `skills/registry/registry.json`."
73. **Промпт**: "Собери первую волну интеграции из `openclaw_catalog.json`: только `Высокая` нужность + `direct` совместимость + низкий риск, лимит 20 навыков."
74. **Промпт**: "Добавь policy-gate: для навыков с shell/network/computer доступом обязателен approval и пониженный timeout. Логи решений сохраняй в run events."
75. **Промпт**: "Сделай набор тестов `tests/test_openclaw_importer.py`: парсинг markdown-каталога, дедуп, dry-run, сериализация каталога, корректная классификация `direct|adapter|blocked`."
76. **Промпт**: "Добавь интеграционные тесты `tests/test_skill_batch_rollout.py`: подключение батча, выполнение smoke-задач, откат при падениях, сохранность существующих skills."
77. **Промпт**: "Добавь метрики импорта и исполнения навыков: `import_total`, `import_success`, `compat_direct_rate`, `adapter_rate`, `blocked_rate`, `batch_pass_rate`, `skill_exec_p95_ms`, `skill_crash_rate`, `top_fail_reasons`."
78. **Промпт**: "Сделай отчёт `docs/OPENCLAW_INTEGRATION_REPORT.md` после каждого батча: сколько импортировано, сколько реально совместимо, сколько включено, какие упали и почему."
79. **Промпт**: "Оформи playbook массовой интеграции: как идти волнами `20 -> 50 -> 100 -> 250`, с quality-gate между волнами и автоматическим rollback при деградации."

### Операционный режим этой фазы (через меня, batch-10)

- Я выбираю топ-10 навыков из `docs/OPENCLAW_SKILLS_ASTRA_ASSESSMENT.md` (по нужности + риску + совместимости).
- Интегрирую только эти 10, не трогая следующую волну.
- Прогоняю проверки: unit + integration + smoke.
- Снимаю метрики: pass-rate, p95, crash-rate, top fail reasons.
- Даю отчёт после волны: что подключили, что не взлетело, что отправили в `blocked`, что откатили.
- После твоего "ок" запускается следующая десятка.

DoD фазы 8:
- Каталог OpenClaw импортируется воспроизводимо и в dry-run, и в apply-режиме.
- Есть автотесты парсера/импортёра/батч-роллаута и они зелёные.
- По каждой волне есть метрики качества и отчёт с причинами фейлов.
- Интеграция идёт батчами с rollback, без деградации текущих core-функций Astra.

## Стоп-правила (обязательно)

- Если после любой фазы качество падает — откат до последней стабильной точки.
- Не добавлять новые фреймворки “ради фреймворков”; сначала выжать максимум из текущей архитектуры.
- Фаза считается закрытой только после зелёных тестов и короткого отчёта по метрикам.
- Отложенную фазу автопилота начинать только в самом конце, когда фазы до интеграции OpenClaw уже стабилизированы.
